---
title: "構造に関するパターン 概要"
---

# 構造に関するパターン（Structural Patterns）

## 概要

構造に関するパターンは、クラスやオブジェクトを組み合わせて、より大きな構造を形成するパターン群です。オブジェクト間の関係を整理し、システムの柔軟性と再利用性を高めます。

## なぜ構造パターンが必要か

ソフトウェア開発では、以下のような課題に直面します：

1. **互換性のないインターフェース**: 既存のコードと新しいコードをつなげたい
2. **複雑な階層構造**: 部分と全体を同じように扱いたい
3. **機能の追加**: 既存のオブジェクトに動的に機能を追加したい
4. **複雑なサブシステム**: シンプルなインターフェースで隠蔽したい

構造パターンを使うことで、これらの課題を elegant に解決できます。

## Goにおける構造パターン

Go言語の特徴が構造パターンの実装に影響します：

```go
// 埋め込み（Embedding）: 継承の代わりに使用
type Logger struct {
    *FileWriter  // FileWriterのメソッドをLoggerのメソッドとして使える
}

// インターフェース: 暗黙的実装
type Reader interface {
    Read(p []byte) (n int, err error)
}
// 明示的なimplementsは不要
```

## 7つの構造パターン

| パターン | 目的 | Goでの特徴 |
|---------|------|-----------|
| **Adapter** | インターフェースを変換 | 埋め込みまたはラッパーで実現 |
| **Bridge** | 抽象と実装を分離 | インターフェースと構造体の組み合わせ |
| **Composite** | ツリー構造を表現 | 再帰的な構造体定義 |
| **Decorator** | 動的に機能を追加 | インターフェースを満たすラッパー |
| **Facade** | 複雑さを隠蔽 | シンプルなAPI関数/構造体 |
| **Flyweight** | メモリ効率を改善 | sync.Poolやキャッシュで実現 |
| **Proxy** | アクセスを制御 | 同じインターフェースを実装 |

## いつどのパターンを使うか

```
既存のインターフェースを別のインターフェースに変換したい
  → Adapter

抽象化レイヤーと実装を独立して変更したい
  → Bridge

部分と全体を同じように扱いたい（ツリー構造）
  → Composite

オブジェクトに動的に責務を追加したい
  → Decorator

複雑なサブシステムへの簡単なインターフェースが欲しい
  → Facade

多数の類似オブジェクトを効率的に共有したい
  → Flyweight

オブジェクトへのアクセスを制御したい
  → Proxy
```

## パターン同士の関係

構造パターンは互いに関連しています：

- **Adapter vs Bridge**: Adapterは後付けで互換性を確保、Bridgeは設計時に分離を意識
- **Adapter vs Decorator**: Adapterはインターフェース変換、Decoratorは機能追加
- **Composite vs Decorator**: どちらも再帰的な構造だが、目的が異なる
- **Facade vs Adapter**: Facadeは複雑さを隠蔽、Adapterはインターフェースを変換

## 本章の流れ

次章以降、各パターンを以下の流れで解説します：

1. **Adapter**: 既存インターフェースを新しいインターフェースに変換
2. **Bridge**: 抽象と実装を分離して独立に拡張可能に
3. **Composite**: 部分-全体の階層構造を統一的に扱う
4. **Decorator**: オブジェクトに動的に機能を追加
5. **Facade**: 複雑なサブシステムへのシンプルなインターフェース
6. **Flyweight**: 多数のオブジェクトを効率的に共有
7. **Proxy**: オブジェクトへのアクセスを制御

それでは、Adapterパターンから始めましょう。
