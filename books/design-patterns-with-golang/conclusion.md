---
title: "まとめ"
---

# まとめ

## 本書で学んだこと

本書では、GoF（Gang of Four）が提唱した23のデザインパターンを、Go言語の特性を活かしたサンプルコードとともに学びました。

### 生成に関するパターン（5パターン）

| パターン | 目的 | Goでのキーポイント |
|---------|------|------------------|
| Singleton | インスタンスを1つに制限 | `sync.Once`で安全に実装 |
| Factory Method | 生成をサブクラスに委譲 | インターフェースと関数で実現 |
| Abstract Factory | 関連オブジェクト群を生成 | インターフェースの組み合わせ |
| Builder | 複雑なオブジェクトを段階的に構築 | メソッドチェーン、Functional Options |
| Prototype | 既存オブジェクトをコピー | Clone メソッドの実装 |

### 構造に関するパターン（7パターン）

| パターン | 目的 | Goでのキーポイント |
|---------|------|------------------|
| Adapter | インターフェースを変換 | 埋め込みまたはラッパー |
| Bridge | 抽象と実装を分離 | インターフェースと構造体 |
| Composite | ツリー構造を表現 | 再帰的な構造体定義 |
| Decorator | 動的に機能を追加 | 同じインターフェースを実装するラッパー |
| Facade | 複雑さを隠蔽 | シンプルなAPI関数/構造体 |
| Flyweight | メモリ効率を改善 | `sync.Pool`、キャッシュ |
| Proxy | アクセスを制御 | 同じインターフェースを実装 |

### 振る舞いに関するパターン（11パターン）

| パターン | 目的 | Goでのキーポイント |
|---------|------|------------------|
| Chain of Responsibility | リクエストを連鎖で処理 | HTTPミドルウェア |
| Command | 操作をオブジェクト化 | 関数型でシンプルに |
| Interpreter | 文法を解釈 | DSL、式評価 |
| Iterator | 要素に順次アクセス | チャネル、for-range |
| Mediator | 通信を仲介 | イベントバス、ハブ |
| Memento | 状態の保存・復元 | 値コピー、JSONシリアライズ |
| Observer | 状態変化を通知 | チャネル、コールバック |
| State | 状態に応じて振る舞い変更 | インターフェースで状態を表現 |
| Strategy | アルゴリズムを交換可能に | 関数型で自然に実装 |
| Template Method | アルゴリズムの骨格を定義 | 埋め込みと関数 |
| Visitor | 構造を変えずに操作を追加 | ダブルディスパッチ |

## Goとデザインパターン

Go言語は従来のクラスベースOOP言語とは異なりますが、デザインパターンの本質は十分に適用できます。むしろ、Goの特性を活かすことで、より簡潔な実装が可能になることも多いです。

### Goの特性とパターンの相性

1. **インターフェース（暗黙的実装）**
   - Adapter、Strategy、State などで威力を発揮
   - 実装を宣言せずにインターフェースを満たせる

2. **関数型（第一級関数）**
   - Strategy、Command、Template Method を関数で実装可能
   - コールバックパターンが自然に書ける

3. **チャネルとゴルーチン**
   - Observer、Mediator の実装に最適
   - 並行処理を安全に扱える

4. **埋め込み（Embedding）**
   - 継承の代わりにコンポジションを実現
   - Decorator、Template Method で活用

5. **構造体の値コピー**
   - Prototype、Memento でシンプルに状態をコピー

## パターン選択のガイド

```
「何を作りたいか」から考える：

オブジェクトの生成方法を柔軟にしたい
  └→ Singleton, Factory Method, Abstract Factory, Builder, Prototype

既存のコードを新しいシステムに組み込みたい
  └→ Adapter, Facade

オブジェクト間の関係を整理したい
  └→ Bridge, Composite, Decorator, Proxy

オブジェクト間の通信を整理したい
  └→ Chain of Responsibility, Mediator, Observer

振る舞いを柔軟に変更したい
  └→ Strategy, State, Template Method

操作を記録・復元したい
  └→ Command, Memento

データと操作を分離したい
  └→ Visitor
```

## パターンを学ぶ意義

デザインパターンを学ぶ本当の価値は、以下の点にあります：

1. **共通語彙の獲得**
   - チームメンバーと設計について議論しやすくなる
   - 「ここはStrategyパターンで」と一言で意図が伝わる

2. **設計の引き出しを増やす**
   - 問題に直面したとき、解決策の選択肢が増える
   - 車輪の再発明を避けられる

3. **コードリーディング力の向上**
   - 他人のコードやライブラリの設計意図を理解しやすくなる
   - 標準ライブラリのパターンを認識できる

4. **パターンの本質の理解**
   - 「なぜそうするのか」を理解することで、応用が利く
   - 言語が変わっても考え方は活かせる

## 次のステップ

本書で学んだパターンを実践で活かすために：

1. **実際のコードで使ってみる**
   - 小さなプロジェクトでパターンを試す
   - 既存コードのリファクタリングで適用を検討

2. **標準ライブラリを読む**
   - `io.Reader`/`io.Writer`（Strategy的）
   - `http.Handler`（Decorator、Chain of Responsibility）
   - `sort.Interface`（Strategy）
   - `context.Context`（各種パターンとの組み合わせ）

3. **過度な適用を避ける**
   - パターンは目的ではなく手段
   - シンプルな解決策で十分な場合はパターンを使わない
   - YAGNI（You Ain't Gonna Need It）を意識

## おわりに

デザインパターンは「銀の弾丸」ではありませんが、ソフトウェア設計の重要な道具です。本書で学んだ知識を活かして、より保守性が高く、拡張しやすいGoコードを書いていただければ幸いです。

Go言語のシンプルさと、デザインパターンの知恵を組み合わせて、素晴らしいソフトウェアを作りましょう！

Happy Coding! 🚀
