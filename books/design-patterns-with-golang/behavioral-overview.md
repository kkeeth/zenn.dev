---
title: "振る舞いに関するパターン 概要"
---

# 振る舞いに関するパターン（Behavioral Patterns）

## 概要

振る舞いに関するパターンは、オブジェクト間の責務分担とコミュニケーションに関するパターン群です。オブジェクトがどのように協調して動作するかを定義します。

## なぜ振る舞いパターンが必要か

ソフトウェア開発では、以下のような課題に直面します：

1. **責務の分離**: オブジェクトの責務を適切に分担したい
2. **柔軟なアルゴリズム**: アルゴリズムを実行時に切り替えたい
3. **オブジェクト間の通信**: 疎結合な通信を実現したい
4. **状態管理**: 状態に応じた振る舞いの変更を管理したい

振る舞いパターンを使うことで、これらの課題を elegant に解決できます。

## Goにおける振る舞いパターン

Go言語の特徴が振る舞いパターンの実装に影響します：

```go
// 関数型（Strategyパターンに最適）
type SortFunc func(data []int) []int

// チャネル（Observerパターンの実装）
type Observer chan Event

// インターフェース（多くのパターンの基盤）
type Handler interface {
    Handle(request Request) Response
}
```

## 11の振る舞いパターン

| パターン | 目的 | Goでの特徴 |
|---------|------|-----------|
| **Chain of Responsibility** | リクエストを処理者の連鎖に渡す | ミドルウェアパターンで頻出 |
| **Command** | リクエストをオブジェクト化 | 関数型でシンプルに実装可能 |
| **Interpreter** | 言語の文法を解釈 | DSLやテンプレートエンジンで使用 |
| **Iterator** | 要素への順次アクセス | channelやfor-rangeで自然に実装 |
| **Mediator** | オブジェクト間の通信を仲介 | イベントバスやハブで実現 |
| **Memento** | 状態の保存と復元 | 構造体のコピーで実装 |
| **Observer** | 状態変化を通知 | channelやコールバックで実装 |
| **State** | 状態に応じて振る舞いを変更 | インターフェースで状態を表現 |
| **Strategy** | アルゴリズムをカプセル化 | 関数型で非常に自然に実装 |
| **Template Method** | アルゴリズムの骨格を定義 | 埋め込みとインターフェースで実現 |
| **Visitor** | 構造を変えずに操作を追加 | インターフェースで実装 |

## いつどのパターンを使うか

```
リクエストを複数の処理者に順番に渡したい
  → Chain of Responsibility

リクエストをオブジェクトとして扱いたい（取り消し、キュー等）
  → Command

独自の言語や文法を解釈したい
  → Interpreter

コレクションの要素に順次アクセスしたい
  → Iterator

多数のオブジェクト間の通信を整理したい
  → Mediator

オブジェクトの状態を保存・復元したい
  → Memento

状態変化を複数のオブジェクトに通知したい
  → Observer

状態に応じてオブジェクトの振る舞いを変えたい
  → State

アルゴリズムを実行時に切り替えたい
  → Strategy

アルゴリズムの骨格を定義し、一部をサブクラスで実装したい
  → Template Method

構造を変えずに新しい操作を追加したい
  → Visitor
```

## 本章の流れ

次章以降、各パターンを以下の流れで解説します：

1. **Chain of Responsibility**: リクエストをハンドラの連鎖で処理
2. **Command**: 操作をオブジェクトとしてカプセル化
3. **Interpreter**: 文法規則を解釈して実行
4. **Iterator**: コレクションを順次走査
5. **Mediator**: オブジェクト間の通信を集中管理
6. **Memento**: オブジェクトの状態を保存・復元
7. **Observer**: イベントを購読者に通知
8. **State**: 状態に応じて振る舞いを変更
9. **Strategy**: アルゴリズムを交換可能に
10. **Template Method**: アルゴリズムの骨格を定義
11. **Visitor**: データ構造と操作を分離

それでは、Chain of Responsibilityパターンから始めましょう。
